[{"id":"9ac52bc1.20e278","type":"tab","label":"Ejemplo MODBUS","disabled":false,"info":""},{"id":"5c761764.55e4c8","type":"tab","label":"Leer temperatura","disabled":false,"info":""},{"id":"cd739a52.e94e38","type":"tab","label":"Dashboard","disabled":false,"info":""},{"id":"15d4ce14.0555a2","type":"tab","label":"Servidor OPC-UA","disabled":false,"info":""},{"id":"5b7b7318.8a709c","type":"tab","label":"Lectura y escritura OPCUA","disabled":false,"info":""},{"id":"ba721049.8f30e","type":"modbus-client","z":"","name":"Servidor_Prueba","clienttype":"tcp","bufferCommands":false,"stateLogEnabled":true,"queueLogEnabled":false,"tcpHost":"127.0.0.1","tcpPort":"502","tcpType":"DEFAULT","serialPort":"/dev/ttyUSB","serialType":"RTU-BUFFERD","serialBaudrate":"9600","serialDatabits":"8","serialStopbits":"1","serialParity":"none","serialConnectionDelay":"100","unit_id":"1","commandDelay":"10","clientTimeout":"1000","reconnectOnTimeout":false,"reconnectTimeout":"2000","parallelUnitIdsAllowed":false},{"id":"c9718344.31eab","type":"ui_tab","z":"","name":"Home","icon":"dashboard","disabled":false,"hidden":false},{"id":"f45032ce.02a07","type":"ui_group","z":"","name":"General","tab":"c9718344.31eab","disp":true,"width":"6","collapse":false},{"id":"6078a428.d44cec","type":"OPCUA-IIoT-Connector","z":"","discoveryUrl":"","endpoint":"opc.tcp://localhost:55380/","keepSessionAlive":true,"loginEnabled":false,"securityPolicy":"None","securityMode":"NONE","name":"Servidor","showErrors":false,"individualCerts":false,"publicCertificateFile":"","privateKeyFile":"","defaultSecureTokenLifetime":"","endpointMustExist":false,"autoSelectRightEndpoint":false,"strategyMaxRetry":"","strategyInitialDelay":"","strategyMaxDelay":"","strategyRandomisationFactor":"","requestedSessionTimeout":"","connectionStartDelay":"","reconnectDelay":"","maxBadSessionRequests":"10"},{"id":"13d09467.bbae9c","type":"catch","z":"9ac52bc1.20e278","name":"","scope":[],"uncaught":false,"x":250,"y":560,"wires":[["a326d215.64df"]]},{"id":"a326d215.64df","type":"debug","z":"9ac52bc1.20e278","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":460,"y":580,"wires":[]},{"id":"3b0ef118.b6cf6e","type":"modbus-read","z":"9ac52bc1.20e278","name":"","topic":"","showStatusActivities":false,"logIOActivities":false,"showErrors":false,"unitid":"0","dataType":"HoldingRegister","adr":"0","quantity":"10","rate":"1000","rateUnit":"ms","delayOnStart":false,"startDelayTime":"10","server":"ba721049.8f30e","useIOFile":false,"ioFile":"","useIOForPayload":false,"x":150,"y":180,"wires":[["bfdaaad8.d37708"],["e89d9ae1.834e58"]]},{"id":"e89d9ae1.834e58","type":"modbus-response","z":"9ac52bc1.20e278","name":"","registerShowMax":"20","x":450,"y":220,"wires":[]},{"id":"bfdaaad8.d37708","type":"debug","z":"9ac52bc1.20e278","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","x":410,"y":120,"wires":[]},{"id":"2123eab.a837f16","type":"comment","z":"9ac52bc1.20e278","name":"Prueba Modbus","info":"Escribe y lee valores sobre un servidor local","x":160,"y":100,"wires":[]},{"id":"2656a538.16889a","type":"modbus-write","z":"9ac52bc1.20e278","name":"","showStatusActivities":true,"showErrors":true,"unitid":"0","dataType":"MHoldingRegisters","adr":"0","quantity":"10","server":"ba721049.8f30e","x":440,"y":420,"wires":[["17672016.66fcd"],["458fbcd3.86d154"]]},{"id":"3b8eba40.58d856","type":"inject","z":"9ac52bc1.20e278","name":"","topic":"","payload":"[1,2,3,4,5,6,7,8,9,10]","payloadType":"json","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":200,"y":400,"wires":[["2656a538.16889a"]]},{"id":"17672016.66fcd","type":"debug","z":"9ac52bc1.20e278","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":650,"y":380,"wires":[]},{"id":"458fbcd3.86d154","type":"modbus-response","z":"9ac52bc1.20e278","name":"","registerShowMax":20,"x":650,"y":460,"wires":[]},{"id":"a4e46bec.74d828","type":"inject","z":"9ac52bc1.20e278","name":"","topic":"","payload":"[10,9,8,7,6,5,4,3,2,1]","payloadType":"json","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":200,"y":460,"wires":[["2656a538.16889a"]]},{"id":"5abfa088.e4dfd","type":"inject","z":"5c761764.55e4c8","name":"tick","topic":"tempC","payload":"","payloadType":"str","repeat":"1","crontab":"","once":false,"onceDelay":"","x":77,"y":142,"wires":[["2c9987e0.f5b358"]]},{"id":"8def9762.fb3bf8","type":"comment","z":"5c761764.55e4c8","name":"Leer la temperatura de la CPU de la PI","info":"Lanza el comando vcgencmd measure_temp\ny formatea el resultado, extrayendo el valor\n","x":177,"y":82,"wires":[]},{"id":"10d30372.a3deed","type":"debug","z":"5c761764.55e4c8","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":427,"y":146,"wires":[]},{"id":"58df558c.6e3eac","type":"link out","z":"5c761764.55e4c8","name":"Temperatura PI","links":["8409aea9.8b3af","b2a64d77.37486"],"x":475,"y":220,"wires":[]},{"id":"2c9987e0.f5b358","type":"function","z":"5c761764.55e4c8","name":"Sin(x)","func":"if (typeof x == 'undefined'){\n    x = 0;\n}\n\nmsg.payload = Math.sin(x);\n\nx = x + 0.05;\n\nif(x == 1) x = 0;\n\nreturn msg;","outputs":1,"noerr":0,"x":240,"y":160,"wires":[["10d30372.a3deed","58df558c.6e3eac"]]},{"id":"8d4e00fb.ab973","type":"ui_chart","z":"cd739a52.e94e38","name":"","group":"f45032ce.02a07","order":0,"width":0,"height":0,"label":"chart","chartType":"line","legend":"false","xformat":"HH:mm:ss","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":1,"removeOlderPoints":"","removeOlderUnit":"3600","cutout":0,"useOneColor":false,"useUTC":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":370,"y":80,"wires":[[]]},{"id":"8409aea9.8b3af","type":"link in","z":"cd739a52.e94e38","name":"","links":["58df558c.6e3eac"],"x":140,"y":100,"wires":[["8d4e00fb.ab973"]]},{"id":"e5c80d1c.a8e09","type":"OPCUA-IIoT-Flex-Server","z":"15d4ce14.0555a2","port":"55380","endpoint":"","acceptExternalCommands":true,"maxAllowedSessionNumber":"","maxConnectionsPerEndpoint":"","maxAllowedSubscriptionNumber":"","alternateHostname":"","name":"","showStatusActivities":false,"showErrors":false,"allowAnonymous":true,"individualCerts":false,"isAuditing":false,"serverDiscovery":true,"users":[],"xmlsets":[],"publicCertificateFile":"","privateCertificateFile":"","registerServerMethod":1,"discoveryServerEndpointUrl":"","capabilitiesForMDNS":"","maxNodesPerRead":1000,"maxNodesPerBrowse":2000,"delayToClose":1000,"addressSpaceScript":"/*function constructAlarmAddressSpace(server, addressSpace, eventObjects, done) {\n    // server = the created node-opcua server\n    // addressSpace = script placeholder\n    // eventObjects = to hold event variables in memory from this script\n    \n    // internal global sandbox objects are \n    // node = node of the flex server, \n    // coreServer = core iiot server object for debug and access to nodeOPCUA,\n    // and scriptObjects to hold variables and functions\n    const LocalizedText = coreServer.core.nodeOPCUA.LocalizedText\n    const namespace = addressSpace.getOwnNamespace()\n\n    coreServer.internalDebugLog('init dynamic address space')\n    node.warn('construct new address space for OPC UA')\n    \n    // from here - see the node-opcua docs how to build address sapces\n    let tanks = namespace.addObject({\n        browseName: 'Tanks',\n        description: 'The Object representing some tanks',\n        organizedBy: addressSpace.rootFolder.objects,\n        notifierOf: addressSpace.rootFolder.objects.server\n    })\n    \n    let oilTankLevel = namespace.addVariable({\n        browseName: 'OilTankLevel',\n        displayName: [\n          new LocalizedText({text: 'Oil Tank Level', locale: 'en-US'}),\n          new LocalizedText({text: 'Öl Tank Füllstand', locale: 'de-DE'})\n        ],\n        description: 'Fill level in percentage (0% to 100%) of the oil tank',\n        propertyOf: tanks,\n        dataType: 'Double',\n        eventSourceOf: tanks\n    })\n    \n    // ---------------------------------------------------------------------------------\n    // Let's create a exclusive Limit Alarm that automatically raise itself\n    // when the tank level is out of limit\n    // ---------------------------------------------------------------------------------\n    let exclusiveLimitAlarmType = addressSpace.findEventType('ExclusiveLimitAlarmType')\n    node.bianco.iiot.assert(exclusiveLimitAlarmType !== null)\n    \n    let oilTankLevelCondition = namespace.instantiateExclusiveLimitAlarm(exclusiveLimitAlarmType, {\n        componentOf: tanks,\n        conditionSource: oilTankLevel,\n        browseName: 'OilTankLevelCondition',\n        displayName: [\n          new LocalizedText({text: 'Oil Tank Level Condition', locale: 'en-US'}),\n          new LocalizedText({text: 'Öl Tank Füllstand Bedingung', locale: 'de-DE'})\n        ],\n        description: 'ExclusiveLimitAlarmType Condition',\n        conditionName: 'OilLevelCondition',\n        optionals: [\n          'ConfirmedState', 'Confirm' // confirm state and confirm Method\n        ],\n        inputNode: oilTankLevel,   // the letiable that will be monitored for change\n        highHighLimit: 0.9,\n        highLimit: 0.8,\n        lowLimit: 0.2\n    })\n    \n    // --------------------------------------------------------------\n    // Let's create a second letiable with no Exclusive alarm\n    // --------------------------------------------------------------\n    let gasTankLevel = namespace.addVariable({\n        browseName: 'GasTankLevel',\n        displayName: [\n          new LocalizedText({text: 'Gas Tank Level', locale: 'en-US'}),\n          new LocalizedText({text: 'Gas Tank Füllstand', locale: 'de-DE'})\n        ],\n        description: 'Fill level in percentage (0% to 100%) of the gas tank',\n        propertyOf: tanks,\n        dataType: 'Double',\n        eventSourceOf: tanks\n    })\n    \n    let nonExclusiveLimitAlarmType = addressSpace.findEventType('NonExclusiveLimitAlarmType')\n    node.bianco.iiot.assert(nonExclusiveLimitAlarmType !== null)\n    \n    let gasTankLevelCondition = namespace.instantiateNonExclusiveLimitAlarm(nonExclusiveLimitAlarmType, {\n        componentOf: tanks,\n        conditionSource: gasTankLevel,\n        browseName: 'GasTankLevelCondition',\n        displayName: [\n          new LocalizedText({text: 'Gas Tank Level Condition', locale: 'en-US'}),\n          new LocalizedText({text: 'Gas Tank Füllstand Bedingung', locale: 'de-DE'})\n        ],\n        description: 'NonExclusiveLimitAlarmType Condition',\n        conditionName: 'GasLevelCondition',\n        optionals: [\n          'ConfirmedState', 'Confirm' // confirm state and confirm Method\n        ],\n        inputNode: gasTankLevel,   // the letiable that will be monitored for change\n        highHighLimit: 0.9,\n        highLimit: 0.8,\n        lowLimit: 0.2\n    })\n    \n    // variable with value\n    if(scriptObjects.testReadWrite === undefined || scriptObjects.testReadWrite === null) {\n            scriptObjects.testReadWrite = 1000.0\n    }\n    \n    let myVariables = namespace.addObject({\n        browseName: 'MyVariables',\n        description: 'The Object representing some variables',\n        organizedBy: addressSpace.rootFolder.objects,\n        notifierOf: addressSpace.rootFolder.objects.server\n    })\n    \n    if(coreServer.core) {\n        namespace.addVariable({\n            componentOf: myVariables,\n            nodeId: 'ns=1;s=TestReadWrite',\n            browseName: 'TestReadWrite',\n            displayName: [\n                new LocalizedText({text: 'Test Read and Write', locale: 'en-US'}),\n                new LocalizedText({text: 'Test Lesen Schreiben', locale: 'de-DE'})\n            ],\n            dataType: 'Double',\n            value: {\n                get: function () {\n                    return new coreServer.core.nodeOPCUA.Variant({\n                        dataType: 'Double',\n                        value: scriptObjects.testReadWrite\n                    })\n                },\n                set: function (variant) {\n                    scriptObjects.testReadWrite = parseFloat(variant.value)\n                    return coreServer.core.nodeOPCUA.StatusCodes.Good\n                }\n            }\n            \n        })\n        \n        let memoryVariable = namespace.addVariable({\n            componentOf: myVariables,\n            nodeId: 'ns=1;s=free_memory',\n            browseName: 'FreeMemory',\n            displayName: [\n                new LocalizedText({text: 'Free Memory', locale: 'en-US'}),\n                new LocalizedText({text: 'ungenutzer RAM', locale: 'de-DE'})\n            ],\n            dataType: 'Double',\n            \n            value: {\n              get: function () {\n                return new coreServer.core.nodeOPCUA.Variant({\n                  dataType: 'Double',\n                  value: coreServer.core.availableMemory()\n                })\n              }\n            }\n        })\n        addressSpace.installHistoricalDataNode(memoryVariable)\n       \n    } else {\n        coreServer.internalDebugLog('coreServer.core needed for coreServer.core.nodeOPCUA')\n    }\n\n    // hold event objects in memory \n    eventObjects.oilTankLevel = oilTankLevel\n    eventObjects.oilTankLevelCondition = oilTankLevelCondition\n    \n    eventObjects.gasTankLevel = gasTankLevel\n    eventObjects.gasTankLevelCondition = gasTankLevelCondition\n    \n    done()\n}*/\nfunction constructAddressSpace(server, addressSpace, eventObjects, done) {\n    // server = the created node-opcua server\n    // addressSpace = script placeholder\n    // eventObjects = to hold event variables in memory from this script\n    \n    // internal global sandbox objects are \n    // node = node of the flex server, \n    // coreServer = core iiot server object for debug and access to nodeOPCUA,\n    // and scriptObjects to hold variables and functions\n    \n    // Creamos constantes para algunos objetos y as simplificar la escritura\n    const miopcua =coreServer.core.nodeOPCUA; \t\t\t\t        // Acceso a nodeopcua\n    const LocalizedText = coreServer.core.nodeOPCUA.LocalizedText \t// Para simplificar textos localizados\n    const namespace = addressSpace.getOwnNamespace()\t\t\t    // Espacio de nombres\n\n    \n    // Pruebas con variables globales -- NO FUNCIONA\n    //const g = node.global();\n    //const g=scriptObjects.global;\n    //global.rpiTemp=1.0;\n\n    //node.warn(g.get('rpiTemp'));\n    \n    // Este mensaje sale en el panel de debug\n    node.warn('Espacio de direcciones gateway PI 1')\n    \n    // Uso de una variable local para mantener un valor sobre el que leer/escribir\n    var fake=0.0\n     //----------------------------------------------------------------------\n    // Creamos un objeto para la Raspberry Pi, nuestro gateway IoT\n    // https://node-opcua.github.io/tutorial/2015/12/05/ObjectType-and-object-instantiation.html\n    //----------------------------------------------------------------------\n    \n    let rpi = namespace.addObject({\n        browseName: 'RPi Gateway',\n        description: 'Objeto que representa una RPi haciendo de gateway IoT',\n        organizedBy: addressSpace.rootFolder.objects,\n        notifierOf: addressSpace.rootFolder.objects.server\n    })\n    \n    \n    //----------------------------------------------------------------------\n    // AÃ±adimos variables al objeto. Hay dos modos, como propertyOf o como\n    // componentOf. La segunda funciona para Leer/Escribir desde un cliente\n    // la primera solo me ha funcionado como solo lectura.\n    //----------------------------------------------------------------------\n        \n    let piTempCPU = namespace.addVariable({\n        propertyOf: rpi,\t\t// Propiedad del objeto (solo lectura)\n        nodeID: 'ns=1;s=piTemp',\n        browseName: 'Temp CPU',\n        \n        displayName: [\n          new LocalizedText({text: 'RPi CPU temp', locale: 'en-US'}),\n          new LocalizedText({text: 'Temperatura CPU de la Pi', locale: 'es-ES'})\n        ],\n        description: 'Temperatura de la CPU de la RPi',\n        dataType: 'Double',\n        eventSourceOf: rpi,\n        value:\n        {   \n            get: function () {\n                return new miopcua.Variant({\n                dataType: 'Double',\n                value:global.rpiTemp\n              })\n            },\n         }\n        \n    })\n  \n    // Vamos a aÃ±adir otra variable para la temperatura de la CPU\n    // de la Pi... pero esta vez como una variable analÃ³gica con\n    // informaciÃ³n de rango y unidades de ingeniera\n    // Para aÃ±adir variables analÃ³gicas con rangos ver\n    // http://node-opcua.github.io/api_doc/0.1.0/classes/AddressSpace.html\n    let piTempCPU2 = namespace.addAnalogDataItem({\n        componentOf: rpi,\t// Componente (tag) del objeto, puede ser L/E\n        nodeID: 'ns=1;s=piTemp2',\n        browseName: 'Temp CPU2',\n\t\n        engineeringUnitsRange: {\n            low:  0,\n            high: 100.0\n        },\n        engineeringUnits: miopcua.standardUnits.degree_celsius,\n\t    // Ver unidades en https://github.com/node-opcua/node-opcua/blob/7ed0ff7a/packages/node-opcua-data-access/source/EUInformation.ts#L87\n        \n        displayName: [\n          new LocalizedText({text: 'RPi CPU temp 2', locale: 'en-US'}),\n          new LocalizedText({text: 'Temperatura CPU de la Pi 2', locale: 'es-ES'})\n        ],\n        description: 'Temperatura de la CPU de la RPi 2',\n        dataType: 'Double',\n        eventSourceOf: rpi,\n        value:\n        {   \n            get: function () {\n              return new miopcua.Variant({\n                dataType: 'Double',\n                value:fake\n              })\n            },\n            set: function (variant) {\n                    fake = parseFloat(variant.value)\n                    return miopcua.StatusCodes.Good\n            }\n        }\n        \n    })\n    \n     // Indicamos que es una variable que historiza\n    addressSpace.installHistoricalDataNode(piTempCPU2);\n    \n    // Vamos a aÃ±adir una Ãºltima variable, pero esta vez que devuelva el \n    // valor de una funciÃ³n interna. Es una variable de solo lectura\n    // que podrmos calcular a partir de otros datos. AdemÃ¡s\n    // vamos a historizarla. La llamaremos PresiÃ³n.\n    \n    let t=0; // contador\n    const simPresion = namespace.addAnalogDataItem({\n        browseName: \"Presion\",\n        //nodeID: 'ns=1;s=Presion',\n        engineeringUnitsRange: {\n            low:  0,\n            high: 10.0\n        },\n        engineeringUnits: miopcua.standardUnits.bar,\n        componentOf: rpi,\n        value:{\n            get: function(){\n                let valuep = (Math.sin(t/50)*0.70+Math.random()*0.20)*5.0+5.0;\n                t=t+1; \n                return new miopcua.Variant({\n                    dataType: miopcua.DataType.Double,\n                    value:valuep\n                  })\n            }\n        }\n    });\n    \n    // Indicamos que es una variable que historiza\n    addressSpace.installHistoricalDataNode(simPresion);\n    \n    \n    //----------------------------------------------------------------------\n    // AÃ±adimos ahora un mÃ©todo al objeto rpi. Primero se aÃ±aden los datos\n    // del mÃ©todo al namespace: nombre, argumentos con tipo y descripciÃ³n,\n    // etc. Luego se hace un bind sobre una funciÃ³n javascript\n    //----------------------------------------------------------------------\n       \n    // AÃ±adimos el mÃ©todo\n    const m1=namespace.addMethod(rpi,{\n        browseName: \"CalcSen\",\n        nodeID:\"ns=1;s=CalcSen\",\n        inputArguments:[{\n            name: \"Angulo (radianes)\",\n            description: {text: \"Angulo en radianes para el seno\"},\n            dataType: 'Double'\n        }],\n        outputArguments:[{\n            name: \"Seno\",\n            description: {text: \"Valor del seno\"},\n            dataType: 'Double'\n        }]\n    })\n    \n    // Y ahora lo atamos a una funciÃ³n\n    m1.bindMethod(function(inputArguments,context,callback) {\n        const angulo = inputArguments[0].value; // Valor del argumento\n\t    // Creamos un objeto para el resultado\n        const callMethodResult = {\n            statusCode: miopcua.StatusCodes.Good,\n            outputArguments: [{\n                    dataType: 'Double',\n                    value : Math.sin(angulo)\n            }]\n        };\n\t// Se devuelve el resultado as:\n        callback(null,callMethodResult);\n    });\n\n \n   //----------------------------------------------------------------------\n   // Una vez terminado el script, hay que llamar a done() para instalarlo\n   //----------------------------------------------------------------------\n   done()\n}","x":460,"y":160,"wires":[[]]},{"id":"cc3c7932.8f3fc8","type":"OPCUA-IIoT-Browser","z":"5b7b7318.8a709c","connector":"6078a428.d44cec","nodeId":"","name":"Servidor_1","justValue":true,"sendNodesToRead":false,"sendNodesToListener":false,"sendNodesToBrowser":false,"singleBrowseResult":false,"recursiveBrowse":false,"recursiveDepth":1,"delayPerMessage":0.2,"showStatusActivities":false,"showErrors":false,"x":110,"y":140,"wires":[[]]},{"id":"b2a64d77.37486","type":"link in","z":"5b7b7318.8a709c","name":"","links":["58df558c.6e3eac"],"x":55,"y":200,"wires":[["1919cf0b.a0ded1"]]},{"id":"1919cf0b.a0ded1","type":"function","z":"5b7b7318.8a709c","name":"Save_RPI_Temp","func":"flow.set('RPiTemp',msg.payload);\nreturn msg;","outputs":1,"noerr":0,"x":190,"y":200,"wires":[[]]},{"id":"f60e3bbb.e6eb18","type":"OPCUA-IIoT-Inject","z":"5b7b7318.8a709c","injectType":"write","payloadType":"date","topic":"","repeat":"0.5","crontab":"","once":false,"startDelay":"","name":"","payload":"","addressSpaceItems":[{"name":"RpiTemp","nodeId":"ns=1;i=1002","datatypeName":"Double"}],"x":110,"y":260,"wires":[["c5ae6364.4e7a7"]]},{"id":"c5ae6364.4e7a7","type":"function","z":"5b7b7318.8a709c","name":"Anade valor RPiTemp","func":"msg.valuesToWrite = [flow.get('RPiTemp')||0]\nreturn msg;","outputs":1,"noerr":0,"x":300,"y":260,"wires":[["5a0bca84.a0db94","71ffa4fc.5bd95c"]]},{"id":"5a0bca84.a0db94","type":"OPCUA-IIoT-Write","z":"5b7b7318.8a709c","connector":"6078a428.d44cec","name":"","justValue":true,"showStatusActivities":false,"showErrors":false,"x":470,"y":200,"wires":[["7e244aa5.988344"]]},{"id":"7e244aa5.988344","type":"OPCUA-IIoT-Response","z":"5b7b7318.8a709c","name":"","compressStructure":true,"showStatusActivities":false,"showErrors":false,"activateUnsetFilter":false,"activateFilters":false,"negateFilter":false,"filters":[],"x":610,"y":260,"wires":[["7cd95018.eea2a"]]},{"id":"7cd95018.eea2a","type":"debug","z":"5b7b7318.8a709c","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":750,"y":260,"wires":[]},{"id":"71ffa4fc.5bd95c","type":"debug","z":"5b7b7318.8a709c","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":610,"y":360,"wires":[]},{"id":"e2672161.cd23","type":"OPCUA-IIoT-Inject","z":"5b7b7318.8a709c","injectType":"read","payloadType":"date","topic":"","repeat":"0.1","crontab":"","once":false,"startDelay":"","name":"","payload":"","addressSpaceItems":[{"name":"","nodeId":"ns=1;i=1002","datatypeName":""}],"x":130,"y":440,"wires":[["ce474439.2b5868"]]},{"id":"ce474439.2b5868","type":"OPCUA-IIoT-Listener","z":"5b7b7318.8a709c","connector":"6078a428.d44cec","action":"subscribe","queueSize":10,"name":"","topic":"","justValue":true,"useGroupItems":false,"showStatusActivities":false,"showErrors":false,"x":320,"y":440,"wires":[["a7150d60.7f5cb"]]},{"id":"a7150d60.7f5cb","type":"OPCUA-IIoT-Result-Filter","z":"5b7b7318.8a709c","nodeId":"ns=1;i=1002","datatype":"Double","fixedValue":false,"fixPoint":2,"withPrecision":false,"precision":2,"entry":1,"justValue":true,"withValueCheck":false,"minvalue":"","maxvalue":"","defaultvalue":"","topic":"","name":"","showErrors":false,"x":520,"y":440,"wires":[["1045e63.7b6191a","c1498321.a975d"]]},{"id":"1045e63.7b6191a","type":"debug","z":"5b7b7318.8a709c","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":720,"y":440,"wires":[]},{"id":"c1498321.a975d","type":"ui_chart","z":"5b7b7318.8a709c","name":"","group":"f45032ce.02a07","order":1,"width":0,"height":0,"label":"chart1","chartType":"line","legend":"false","xformat":"HH:mm:ss","interpolate":"linear","nodata":"","dot":false,"ymin":"","ymax":"","removeOlder":1,"removeOlderPoints":"","removeOlderUnit":"3600","cutout":0,"useOneColor":false,"useUTC":false,"colors":["#1f77b4","#aec7e8","#ff7f0e","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5"],"useOldStyle":false,"outputs":1,"x":710,"y":500,"wires":[[]]}]